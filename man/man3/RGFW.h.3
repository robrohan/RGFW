.TH "RGFW.h" 3 "Mon Jan 6 2025" "RGFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RGFW.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBRGFW_allocator\fP"
.br
.ti -1c
.RI "struct \fBRGFW_point\fP"
.br
.ti -1c
.RI "struct \fBRGFW_rect\fP"
.br
.ti -1c
.RI "struct \fBRGFW_area\fP"
.br
.ti -1c
.RI "struct \fBRGFW_monitor\fP"
.br
.ti -1c
.RI "struct \fBRGFW_Event\fP"
.br
.ti -1c
.RI "struct \fBRGFW_window_src\fP"
.br
.ti -1c
.RI "struct \fBRGFW_window\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBRGFW_UNUSED\fP(x)   (void)(x)"
.br
.ti -1c
.RI "#define \fBRGFW_USERPTR\fP   NULL"
.br
.ti -1c
.RI "#define \fBRGFW_ROUND\fP(x)   (int)((x) >= 0 ? (x) + 0\&.5f : (x) \- 0\&.5f)"
.br
.ti -1c
.RI "#define \fB__USE_POSIX199309\fP"
.br
.ti -1c
.RI "#define \fBRGFW_ALLOC\fP(userptr,  size)   (\fBRGFW_UNUSED\fP(userptr),malloc(size))"
.br
.ti -1c
.RI "#define \fBRGFW_FREE\fP(userptr,  ptr)   (\fBRGFW_UNUSED\fP(userptr),free(ptr))"
.br
.ti -1c
.RI "#define \fBRGFW_MEMCPY\fP(dist,  src,  len)   memcpy(dist, src, len)"
.br
.ti -1c
.RI "#define \fBRGFW_STRNCMP\fP(s1,  s2,  max)   strncmp(s1, s2, max)"
.br
.ti -1c
.RI "#define \fBRGFW_STRTOL\fP(str,  endptr,  base)   strtol(str, endptr, base)"
.br
.ti -1c
.RI "#define \fBinline\fP   __inline"
.br
.ti -1c
.RI "#define \fBRGFWDEF\fP   \fBinline\fP"
.br
.ti -1c
.RI "#define \fBRGFW_ENUM\fP(type,  name)   type name; enum"
.br
.ti -1c
.RI "#define \fBRGFW_HEADER\fP"
.br
.ti -1c
.RI "#define \fBu8\fP   \fBu8\fP"
.br
.ti -1c
.RI "#define \fBb8\fP   \fBb8\fP"
.br
.ti -1c
.RI "#define \fBRGFW_TRUE\fP   (!(0))"
.br
.ti -1c
.RI "#define \fBRGFW_FALSE\fP   0"
.br
.ti -1c
.RI "#define \fBRGFW_OPENGL\fP"
.br
.ti -1c
.RI "#define \fBRGFW_ALPHA\fP   128 /* alpha value for RGFW_transparent (WINAPI ONLY, macOS + linux don't need this) */"
.br
.ti -1c
.RI "#define \fBRGFW_MAX_PATH\fP   260 /* max length of a path (for dnd) */"
.br
.ti -1c
.RI "#define \fBRGFW_MAX_DROPS\fP   260 /* max items you can drop at once */"
.br
.ti -1c
.RI "#define \fBRGFW_CAPSLOCK\fP   (1L << 1)"
.br
.ti -1c
.RI "#define \fBRGFW_NUMLOCK\fP   (1L << 2)"
.br
.ti -1c
.RI "#define \fBRGFW_POINT\fP(x,  y)   (\fBRGFW_point\fP){(\fBi32\fP)(x), (\fBi32\fP)(y)}"
.br
.ti -1c
.RI "#define \fBRGFW_RECT\fP(x,  y,  w,  h)   (\fBRGFW_rect\fP){(\fBi32\fP)(x), (\fBi32\fP)(y), (\fBi32\fP)(w), (\fBi32\fP)(h)}"
.br
.ti -1c
.RI "#define \fBRGFW_AREA\fP(w,  h)   (\fBRGFW_area\fP){(\fBu32\fP)(w), (\fBu32\fP)(h)}"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBu8\fP"
.br
.ti -1c
.RI "typedef int8_t \fBi8\fP"
.br
.ti -1c
.RI "typedef uint16_t \fBu16\fP"
.br
.ti -1c
.RI "typedef int16_t \fBi16\fP"
.br
.ti -1c
.RI "typedef uint32_t \fBu32\fP"
.br
.ti -1c
.RI "typedef int32_t \fBi32\fP"
.br
.ti -1c
.RI "typedef uint64_t \fBu64\fP"
.br
.ti -1c
.RI "typedef int64_t \fBi64\fP"
.br
.ti -1c
.RI "typedef \fBu8\fP \fBb8\fP"
.br
.ti -1c
.RI "typedef \fBu32\fP \fBb32\fP"
.br
.ti -1c
.RI "typedef void *(* \fBRGFW_allocatorMallocfunc\fP) (void *userdata, size_t size)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_allocatorFreefunc\fP) (void *userdata, void *ptr)"
.br
.ti -1c
.RI "typedef struct \fBRGFW_allocator\fP \fBRGFW_allocator\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_monitor\fP \fBRGFW_monitor\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_Event\fP \fBRGFW_Event\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_window_src\fP \fBRGFW_window_src\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_window\fP \fBRGFW_window\fP"
.br
.ti -1c
.RI "typedef void * \fBRGFW_thread\fP"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowmovefunc\fP) (\fBRGFW_window\fP *win, \fBRGFW_rect\fP r)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowresizefunc\fP) (\fBRGFW_window\fP *win, \fBRGFW_rect\fP r)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowquitfunc\fP) (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_focusfunc\fP) (\fBRGFW_window\fP *win, \fBb8\fP inFocus)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mouseNotifyfunc\fP) (\fBRGFW_window\fP *win, \fBRGFW_point\fP point, \fBb8\fP status)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mouseposfunc\fP) (\fBRGFW_window\fP *win, \fBRGFW_point\fP point)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_dndInitfunc\fP) (\fBRGFW_window\fP *win, \fBRGFW_point\fP point)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowrefreshfunc\fP) (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_keyfunc\fP) (\fBRGFW_window\fP *win, \fBu32\fP key, \fBu32\fP mappedKey, \fBu8\fP lockState, \fBb8\fP pressed)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mousebuttonfunc\fP) (\fBRGFW_window\fP *win, \fBu8\fP button, double scroll, \fBb8\fP pressed)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_gamepadButtonfunc\fP) (\fBRGFW_window\fP *win, \fBu16\fP gamepad, \fBu8\fP button, \fBb8\fP pressed)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_gamepadAxisfunc\fP) (\fBRGFW_window\fP *win, \fBu16\fP gamepad, \fBRGFW_point\fP axis[2], \fBu8\fP axisesCount, \fBu8\fP whichAxis)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_gamepadfunc\fP) (\fBRGFW_window\fP *win, \fBu16\fP gamepad, \fBb8\fP connected)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_dndfunc\fP) (\fBRGFW_window\fP *win, char droppedFiles[\fBRGFW_MAX_DROPS\fP][\fBRGFW_MAX_PATH\fP], \fBu32\fP droppedFilesCount)"
.br
.ti -1c
.RI "typedef DWORD(__stdcall * \fBRGFW_threadFunc_ptr\fP) (LPVOID lpThreadParameter)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBRGFW_mouse_codes\fP { \fBRGFW_mouseNone\fP = 0, \fBRGFW_mouseLeft\fP, \fBRGFW_mouseMiddle\fP, \fBRGFW_mouseRight\fP, \fBRGFW_mouseScrollUp\fP, \fBRGFW_mouseScrollDown\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_allocator\fP \fBRGFW_loadAllocator\fP (\fBRGFW_allocator\fP allocator)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_alloc\fP (size_t len)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_free\fP (void *ptr)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_eventTypes)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_gamepadCodes)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_monitor\fP * \fBRGFW_getMonitors\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_monitor\fP \fBRGFW_getPrimaryMonitor\fP (void)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu16\fP, RGFW_windowArgs)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setClassName\fP (const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setBufferSize\fP (\fBRGFW_area\fP size)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_createWindow\fP (const char *name, \fBRGFW_rect\fP rect, RGFW_windowArgs args)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_area\fP \fBRGFW_getScreenSize\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_Event\fP * \fBRGFW_window_checkEvent\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBi32\fP, RGFW_eventWait)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_eventWait\fP (\fBRGFW_window\fP *win, \fBi32\fP waitMS)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_checkEvents\fP (\fBRGFW_window\fP *win, \fBi32\fP waitMS)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_stopCheckEvents\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_close\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_move\fP (\fBRGFW_window\fP *win, \fBRGFW_point\fP v)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveToMonitor\fP (\fBRGFW_window\fP *win, \fBRGFW_monitor\fP m)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_resize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMinSize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMaxSize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_maximize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_minimize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_restore\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setBorder\fP (\fBRGFW_window\fP *win, \fBb8\fP border)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setDND\fP (\fBRGFW_window\fP *win, \fBb8\fP allow)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMousePassthrough\fP (\fBRGFW_window\fP *win, \fBb8\fP passthrough)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setName\fP (\fBRGFW_window\fP *win, char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setIcon\fP (\fBRGFW_window\fP *win, \fBu8\fP *icon, \fBRGFW_area\fP a, \fBi32\fP channels)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMouse\fP (\fBRGFW_window\fP *win, \fBu8\fP *image, \fBRGFW_area\fP a, \fBi32\fP channels)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMouseStandard\fP (\fBRGFW_window\fP *win, \fBu8\fP mouse)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMouseDefault\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_mouseHold\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP area)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_mouseUnhold\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_hide\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_show\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setShouldClose\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_point\fP \fBRGFW_getGlobalMousePoint\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_point\fP \fBRGFW_window_getMousePoint\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_showMouse\fP (\fBRGFW_window\fP *win, \fBi8\fP show)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_point\fP v)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_window_shouldClose\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_window_isFullscreen\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_window_isHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_window_isMinimized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_window_isMaximized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_scaleToMonitor\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_monitor\fP \fBRGFW_window_getMonitor\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isPressed\fP (\fBRGFW_window\fP *win, \fBu8\fP key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_wasPressed\fP (\fBRGFW_window\fP *win, \fBu8\fP key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isHeld\fP (\fBRGFW_window\fP *win, \fBu8\fP key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isReleased\fP (\fBRGFW_window\fP *win, \fBu8\fP key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isClicked\fP (\fBRGFW_window\fP *win, \fBu8\fP key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isMousePressed\fP (\fBRGFW_window\fP *win, \fBu8\fP button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isMouseHeld\fP (\fBRGFW_window\fP *win, \fBu8\fP button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_isMouseReleased\fP (\fBRGFW_window\fP *win, \fBu8\fP button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBb8\fP \fBRGFW_wasMousePressed\fP (\fBRGFW_window\fP *win, \fBu8\fP button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP char * \fBRGFW_readClipboard\fP (size_t *size)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_clipboardFree\fP (char *str)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_writeClipboard\fP (const char *text, \fBu32\fP textLen)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowmovefunc\fP \fBRGFW_setWindowMoveCallback\fP (\fBRGFW_windowmovefunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowresizefunc\fP \fBRGFW_setWindowResizeCallback\fP (\fBRGFW_windowresizefunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowquitfunc\fP \fBRGFW_setWindowQuitCallback\fP (\fBRGFW_windowquitfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mouseposfunc\fP \fBRGFW_setMousePosCallback\fP (\fBRGFW_mouseposfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowrefreshfunc\fP \fBRGFW_setWindowRefreshCallback\fP (\fBRGFW_windowrefreshfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_focusfunc\fP \fBRGFW_setFocusCallback\fP (\fBRGFW_focusfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mouseNotifyfunc\fP \fBRGFW_setMouseNotifyCallBack\fP (\fBRGFW_mouseNotifyfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_dndfunc\fP \fBRGFW_setDndCallback\fP (\fBRGFW_dndfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_dndInitfunc\fP \fBRGFW_setDndInitCallback\fP (\fBRGFW_dndInitfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_keyfunc\fP \fBRGFW_setKeyCallback\fP (\fBRGFW_keyfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mousebuttonfunc\fP \fBRGFW_setMouseButtonCallback\fP (\fBRGFW_mousebuttonfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_gamepadButtonfunc\fP \fBRGFW_setgamepadButtonCallback\fP (\fBRGFW_gamepadButtonfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_gamepadAxisfunc\fP \fBRGFW_setgamepadAxisCallback\fP (\fBRGFW_gamepadAxisfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_gamepadfunc\fP \fBRGFW_setGamepadCallback\fP (\fBRGFW_gamepadfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_thread\fP \fBRGFW_createThread\fP (\fBRGFW_threadFunc_ptr\fP ptr, void *args)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_cancelThread\fP (\fBRGFW_thread\fP thread)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_joinThread\fP (\fBRGFW_thread\fP thread)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setThreadPriority\fP (\fBRGFW_thread\fP thread, \fBu8\fP priority)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_gamepadType)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu32\fP \fBRGFW_isPressedgamepad\fP (\fBRGFW_window\fP *win, \fBu8\fP controller, \fBu8\fP button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_point\fP \fBRGFW_getGamepadAxis\fP (\fBRGFW_window\fP *win, \fBu16\fP controller, \fBu16\fP whichAxis)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP char * \fBRGFW_getGamepadName\fP (\fBRGFW_window\fP *win, \fBu16\fP controller)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP size_t \fBRGFW_getGamepadCount\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP RGFW_gamepadType \fBRGFW_getGamepadType\fP (\fBRGFW_window\fP *win, \fBu16\fP controller)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_makeCurrent\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu32\fP \fBRGFW_window_checkFPS\fP (\fBRGFW_window\fP *win, \fBu32\fP fpsCap)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_swapBuffers\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_swapInterval\fP (\fBRGFW_window\fP *win, \fBi32\fP swapInterval)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setGPURender\fP (\fBRGFW_window\fP *win, \fBi8\fP set)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setCPURender\fP (\fBRGFW_window\fP *win, \fBi8\fP set)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setGLStencil\fP (\fBi32\fP stencil)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setGLSamples\fP (\fBi32\fP samples)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setGLStereo\fP (\fBi32\fP stereo)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setGLAuxBuffers\fP (\fBi32\fP auxBuffers)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_glProfile)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setGLVersion\fP (RGFW_glProfile profile, \fBi32\fP major, \fBi32\fP minor)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setDoubleBuffer\fP (\fBb8\fP useDoubleBuffer)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_getProcAddress\fP (const char *procname)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_makeCurrent_OpenGL\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu64\fP \fBRGFW_getTime\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu64\fP \fBRGFW_getTimeNS\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_sleep\fP (\fBu64\fP milisecond)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_Key)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_mouseIcons)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __USE_POSIX199309"

.SS "#define \fBb8\fP   \fBb8\fP"

.SS "#define inline   __inline"

.SS "#define RGFW_ALLOC(userptr, size)   (\fBRGFW_UNUSED\fP(userptr),malloc(size))"

.SS "#define RGFW_ALPHA   128 /* alpha value for RGFW_transparent (WINAPI ONLY, macOS + linux don't need this) */"

.SS "#define RGFW_AREA(w, h)   (\fBRGFW_area\fP){(\fBu32\fP)(w), (\fBu32\fP)(h)}"

.SS "#define RGFW_CAPSLOCK   (1L << 1)"

.SS "#define RGFW_ENUM(type, name)   type name; enum"

.SS "#define RGFW_FALSE   0"

.SS "#define RGFW_FREE(userptr, ptr)   (\fBRGFW_UNUSED\fP(userptr),free(ptr))"

.SS "#define RGFW_HEADER"

.SS "#define RGFW_MAX_DROPS   260 /* max items you can drop at once */"

.SS "#define RGFW_MAX_PATH   260 /* max length of a path (for dnd) */"

.SS "#define RGFW_MEMCPY(dist, src, len)   memcpy(dist, src, len)"

.SS "#define RGFW_NUMLOCK   (1L << 2)"

.SS "#define RGFW_OPENGL"

.SS "#define RGFW_POINT(x, y)   (\fBRGFW_point\fP){(\fBi32\fP)(x), (\fBi32\fP)(y)}"

.SS "#define RGFW_RECT(x, y, w, h)   (\fBRGFW_rect\fP){(\fBi32\fP)(x), (\fBi32\fP)(y), (\fBi32\fP)(w), (\fBi32\fP)(h)}"

.SS "#define RGFW_ROUND(x)   (int)((x) >= 0 ? (x) + 0\&.5f : (x) \- 0\&.5f)"

.SS "#define RGFW_STRNCMP(s1, s2, max)   strncmp(s1, s2, max)"

.SS "#define RGFW_STRTOL(str, endptr, base)   strtol(str, endptr, base)"

.SS "#define RGFW_TRUE   (!(0))"

.SS "#define RGFW_UNUSED(x)   (void)(x)"

.SS "#define RGFW_USERPTR   NULL"

.SS "#define RGFWDEF   \fBinline\fP"

.SS "#define \fBu8\fP   \fBu8\fP"

.SH "Typedef Documentation"
.PP 
.SS "typedef \fBu32\fP \fBb32\fP"

.SS "typedef \fBu8\fP \fBb8\fP"

.SS "typedef int16_t \fBi16\fP"

.SS "typedef int32_t \fBi32\fP"

.SS "typedef int64_t \fBi64\fP"

.SS "typedef int8_t \fBi8\fP"

.SS "typedef struct \fBRGFW_allocator\fP \fBRGFW_allocator\fP"

.SS "typedef void(* RGFW_allocatorFreefunc) (void *userdata, void *ptr)"

.SS "typedef void *(* RGFW_allocatorMallocfunc) (void *userdata, size_t size)"

.SS "typedef struct \fBRGFW_Event\fP \fBRGFW_Event\fP"
Event structure for checking/getting events 
.SS "typedef struct \fBRGFW_monitor\fP \fBRGFW_monitor\fP"
structure for monitor data 
.SS "typedef void* \fBRGFW_thread\fP"
thread type for window 
.SS "typedef struct \fBRGFW_window\fP \fBRGFW_window\fP"
Window structure for managing the window 
.SS "typedef struct \fBRGFW_window_src\fP \fBRGFW_window_src\fP"
source data for the window (used by the APIs) 
.SS "typedef uint16_t \fBu16\fP"

.SS "typedef uint32_t \fBu32\fP"

.SS "typedef uint64_t \fBu64\fP"

.SS "typedef uint8_t \fBu8\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBRGFW_mouse_codes\fP"
mouse button codes (\fBRGFW_Event\&.button\fP) 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIRGFW_mouseNone \fP\fP
no mouse button is pressed 
.TP
\fB\fIRGFW_mouseLeft \fP\fP
left mouse button is pressed 
.TP
\fB\fIRGFW_mouseMiddle \fP\fP
mouse-wheel-button is pressed 
.TP
\fB\fIRGFW_mouseRight \fP\fP
right mouse button is pressed 
.TP
\fB\fIRGFW_mouseScrollUp \fP\fP
mouse wheel is scrolling up 
.TP
\fB\fIRGFW_mouseScrollDown \fP\fP
mouse wheel is scrolling down 
.SH "Function Documentation"
.PP 
.SS "\fBRGFWDEF\fP void * RGFW_alloc (size_t len)"

.SS "typedef RGFW_ENUM (\fBu16\fP, RGFW_windowArgs)"
Optional arguments for making a windows < the window is transparent (only properly works on X11 and MacOS, although it's although for windows)
.PP
< the window doesn't have border
.PP
< the window cannot be resized by the user
.PP
< the window supports drag and drop
.PP
the window should hide the mouse or not (can be toggled later on) using `RGFW_window_mouseShow
.PP
center the window on the screen
.PP
use OpenGL software rendering
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_eventTypes)"
event codes
.PP
< no event has been sent
.PP
< a key has been released
.PP
key event note the code of the key pressed is stored in \fBRGFW_Event\&.key\fP !!Keycodes defined at the bottom of the RGFW_HEADER part of this file!!
.PP
while a string version is stored in RGFW_Event\&.KeyString
.PP
\fBRGFW_Event\&.lockState\fP holds the current lockState this means if CapsLock, NumLock are active or not
.PP
< a mouse button has been pressed (left,middle,right)
.PP
< a mouse button has been released (left,middle,right)
.PP
< the position of the mouse has been changed
.PP
mouse event note the x and y of the mouse can be found in the vector, \fBRGFW_Event\&.point\fP
.PP
\fBRGFW_Event\&.button\fP holds which mouse button was pressed
.PP
< a gamepad was connected
.PP
< a gamepad was disconnected
.PP
< a gamepad button was pressed
.PP
< a gamepad button was released
.PP
< an axis of a gamepad was moved
.PP
gamepad event note \fBRGFW_Event\&.gamepad\fP holds which gamepad was altered, if any \fBRGFW_Event\&.button\fP holds which gamepad button was pressed
.PP
\fBRGFW_Event\&.axis\fP holds the data of all the axis \fBRGFW_Event\&.axisesCount\fP says how many axis there are
.PP
< the window was moved (b the user)
.PP
< the window was resized (by the user), [on webASM this means the browser was resized]
.PP
< window is in focus now
.PP
< window is out of focus now
.PP
< the user clicked the quit button
.PP
< a file has been dropped into the window
.PP
< the start of a dnd event, when the place where the file drop is known
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_gamepadCodes)"
gamepad button codes (based on xbox/playstation), you may need to change these values per controller < or PS X button
.PP
< or PS X button
.PP
< or PS circle button
.PP
< or PS triangle button
.PP
< or PS square button
.PP
< start button
.PP
< select button
.PP
< home button
.PP
< dpad up
.PP
< dpad down
.PP
< dpad left
.PP
< dpad right
.PP
< left bump
.PP
< left trigger
.PP
< right bumper
.PP
< right trigger
.PP
< right thumb stick
.SS "\fBRGFWDEF\fP void RGFW_free (void * ptr)"

.SS "\fBRGFWDEF\fP \fBRGFW_monitor\fP * RGFW_getMonitors (void)"
get an array of all the monitors (max 6) 
.SS "\fBRGFWDEF\fP \fBRGFW_monitor\fP RGFW_getPrimaryMonitor (void)"
get the primary monitor 
.SS "\fBRGFWDEF\fP \fBRGFW_allocator\fP RGFW_loadAllocator (\fBRGFW_allocator\fP allocator)"

.SH "Author"
.PP 
Generated automatically by Doxygen for RGFW from the source code\&.
